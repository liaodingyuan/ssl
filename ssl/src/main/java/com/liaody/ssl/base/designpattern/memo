一、6大设计模式原则
1.单一职责原则 Single Responsibility Priciple SRP原则：应该有且仅有一个原因引起类的变更
	--一个接口一个职责。
	--好处
		类的复杂性降低， 实现什么职责都有清晰明确的定义；
		可读性提高， 复杂性降低， 那当然可读性提高了；
		可维护性提高， 可读性提高， 那当然更容易维护了；
		变更引起的风险降低， 变更是必不可少的， 如果接口的单一职责做得好， 一个接口修改只对相应的实现类有影响， 对其他的接口无影响， 这对系统的扩展性、 维护性都有非常大
的帮助。
	--单一职责原则提出了一个编写程序的标准， 用“职责”或“变化原因”来衡量接口或类设计得是否优良， 但是“职责”和“变化原因”都是不可度量的， 因项目而异， 因环境而异
	--单一原则适用于接口、类、方法，在一个方法中应该尽可能只做一件事
	--有时候很难做到单一原则，我的建议是接口一定要做到单一职责， 类的设计尽量做到只有一个原因引起变化。
2.里氏替换原则：使用使用基类的地方必须能太透明的使用其子类对象
	-- （重点）在类中调用其他类时务必要使用父类或接口， 如果不能使用父类或接口， 则说明类的设计已经违背了LSP原则。
	-- Java的三大特征嘛， 封装、 继承、 多态
	-- 子类是否能够完整地实现父类的业务（子类的不能透明的代替父类，违反了LSP原则）， 否则就会出现像上面的拿枪杀敌人时却发现是把玩具枪的笑话
	--继承的优点与缺点
		优点：
		缺点：
			继承是侵入性的：
			降低了代码的灵活性：
			增强了耦合性：父类要修改方法或者字段就要考虑对子类的影响
	-- 子类可以override父类的方法，同时也可以重载（不加override而且参数不一致，之啊是方法名称相同）
	-- 注意 如果子类不能完整地实现父类的方法， 或者父类的某些方法在子类中已经发生“畸变”， 则建议断开父子继承关系， 采用依赖、 聚集、 组合等关系代替继承。
	--方法中的输入参数称之为前置条件，也就是说前置条件就是你要让我执行， 就必须满足我的条件； 后置条件就是我执行完了需要反馈， 标准是什么
	-- 名称与父类相同，但是又不写override，这就是重载，使得，你没看错，子类的方法与父类的方法发生了重载（准确的来说子类有这一个方法）
	-- 在一个Invoker类中关联了一个父类， 调用了一个父类的方法， 子类可以覆写这个方法， 也可以重载这个方法， 前提是要扩大这个前置条件， 就是输入参数的类型宽于父类的类型覆盖范围。（这样就会直接调用子类的方法）
	-- 父类的一个方法的返回值是一个类型T， 子类的相同方法（重载或覆写） 的返回值为S， 那么里氏替换原则就要求S必须小于等于T， 也就是说， 要么S和T是同一个类型， 要么S是T的子类。也就是说子类override父类的相同方法
	返回的类型可以是父类被override方法的子类型（更具体的类型）
	-- 就是子类的输入参数宽于或等于父类的输入参数， 也就是说你写的这个方法是不会被调用的（子类的方法的参数类型大于父类，那么子类的这个方法不会被调用）
	-- 最佳实践：采用里氏替换原则时， 尽量避免子类的“个性”， 一旦子类有“个性”， 这个子类和父类之间的关系就很难调和了， 把子类当做父类使用， 子类的“个性”被抹杀——委屈了点； 把子类单独作为一个业务来使用， 则会让代码间的耦合关系变得扑朔迷离——缺乏类替
		换的标准

3.依赖倒置原则（DIP）:
	--定义：
		高层模块不应该依赖低层模块， 两者都应该依赖其抽象；每一个逻辑的实现都是由原子逻辑组成的， 不可分割的原子逻辑就是低层模块， 原子逻辑的再组装就是高层模块。
		抽象不应该依赖细节，细节应该依赖抽象：抽象就是指接口或抽象类， 两者都是不能直接被实例化的； 细节就是实现类， 实现接口或继承抽象类而产生的类就是细节， 其特点就是可以直接被实例化，
	-- 依赖倒置原则在Java中的体现:
		● 模块间的依赖通过抽象发生， 实现类之间不发生直接的依赖关系， 其依赖关系是通过接口或抽象类产生的；
		● 接口或抽象类不依赖于实现类；
		● 实现类依赖接口或抽象类。
	-- 依赖倒置原则最精简的定义就是面向接口编程
	-- 采用依赖倒置原则可以减少类间的耦合性， 提高系统的稳定性， 降低并行开发引起的风险， 提高代码的可读性和可维护性
	-- 最佳实践
		*每一个类都尽量都有接口或者抽象类、或者抽象类和接口两者都具有。这是依赖倒置的基本要求， 接口和抽象类都是属于抽象的， 有了抽象才可能依赖倒置。
		*变量的表面类型尽量是接口或者抽象类
		*任何类都不应该从具体类派生（也就是不要extends一个具体类，可以extends一个抽象类或者implements一个接口，这样会比较好）
		*尽量不要复写基类的方法？？？（如果基类是一个抽象类， 而且这个方法已经实现了， 子类尽量不要覆写。 类间依赖的是抽象， 覆写了抽象方法， 对依赖的稳定性会产生一定的影响。）
		* 结合里氏替换原则使用
	-- 在项目中， 大家只要记住是“面向接口编程”就基本上抓住了依赖倒置原则的核


4.接口隔离原则
	-- 隔离的定义
		客户端不应该依赖它不需要的接口
		类间的依赖关系应该建立在最小的接口上
	-- 接口隔离原则与单一职责的审视角度是不相同的， 单一职责要求的是类和接口职责单一， 注重的是职责， 这是业务逻辑上的划分， 而接口隔离原则要求接口的方法尽量少。
	-- 以上把一个臃肿的接口变更为两个独立的接口所依赖的原则就是接口隔离原则，
	-- 根据接口隔离原则拆分接口时， 首先必须满足单一职责原则。单一职责原则，不是把接口定义的最小，而是把它的功能尽量小，完成一类功能而不是完成多种不同的功能
	，要记住单一职责不是简单的拆接口拆成最小
	--根据接口隔离原则拆分接口时， 首先必须满足单一职责原则
	-- 保证接口的纯洁性
		*接口尽量小，根据接口隔离原则拆分接口时， 首先必须满足单一职责原则
		*接口的高内聚： 具体到接口隔离原则就是， 要求在接口中尽量少公布public方法， 接口是对外的承诺， 承诺越少对系统的开发越有利， 变更的风险也就越少， 同时也有利于降低成本
		* 定制服务：采用定制服务就必然有一个要求： 只提供访问者需要的方法
		* 接口的设计是由限度的
	-- 最佳实践：接口隔离原则是对接口的定义， 同时也是对类的定义， 接口和类尽量使用原子接口或原子类来组装
		* 一个接口只服务于一个子模块或业务逻辑
		* 通过业务逻辑压缩接口中的public方法， 接口时常去回顾， 尽量让接口达到“满身筋骨肉”， 而不是“肥嘟嘟”的一大堆方法
		* 已经被污染了的接口， 尽量去修改， 若变更的风险较大， 则采用适配器模式进行转化处理；
		* 了解环境， 拒绝盲从。 每个项目或产品都有特定的环境因素， 别看到大师是这样做的你就照抄。 千万别， 环境不同， 接口拆分的标准就不同。 深入了解业务逻辑， 最好的接口设
			计就出自你的手中

5.迪米特法则（LKP Least Knowledge Principle）
	-- 一个对象应该对其他对象有最少的了解。 通俗地讲， 一个类应该对自己需要耦合或调用的类知道得最少， 你（被耦合或调用的类） 的内部是如何复杂都和我没关系， 那是你的事情， 我就知道你提供的这么多public
		方法， 我就调用这么多， 其他的我一概不关心
	--


6.开闭原则：一个软件实体如类、 模块和函数应该对扩展开放， 对修改关闭。
	-- 为什么要采用开闭原则
		*开闭原则对测试的影响，原有的健壮代码是否可以不修改， 仅仅通过扩展实现变化呢？ 否则， 就需要把原有的测试过程回笼一遍
		*开闭原则可以提高复用性
		* 开闭原则可以提高可维护性
		* 面向对象开发的要求
	-- 开闭原则是一个非常虚的原则， 前面5个原则是对开闭原则的具体解释
	-- 如何使用开闭原则
		* 抽象约束

● Single Responsibility Principle： 单一职责原则
● Open Closed Principle： 开闭原则
● Liskov Substitution Principle： 里氏替换原则
● Law of Demeter： 迪米特法则
● Interface Segregation Principle： 接口隔离原则
● Dependence Inversion Principle： 依赖倒置原则
把这6个原则的首字母（里氏替换原则和迪米特法则的首字母重复， 只取一个） 联合起
来就是SOLID（solid， 稳定的）

作为一个架构师，当你的项目经常由变化的时候，或者需要进行修改的时候，架构是否是很容易满足的。
-- 建立项目规章非常非常重要
-- 预知变化
--

一、接口型模式：适配器模式、外观模式、合成模式、桥接模式
适配类的接口以匹配客户端期望的接口--->适配器模式
为一组类提供一个简单的接口--->外观模式
为单个对象于符合对象提供统一的接口--->合成模式
解除抽象与实现之间的接口耦合，使得二者能够独立演化--->桥接模式

*接口与抽象类：抽象类于接口的三点区别

1.适配器模式：意图在于，使用不同接口的类提供服务为客户端提供它所期望的接口
	参数类型不符合、方法名不符合