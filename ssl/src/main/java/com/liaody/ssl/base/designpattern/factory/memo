1.实际应用场景：在配置文件中读取配置，如果我配置的是db模式，那么返回一个抽象类的子类，从数据库中查询数据。如果配置配置的是cmdb模式，那么去cmdb查询数据。
查询的方法封装在抽象类里面。
2.定义一个用于创建对象的接口， 让子类决定实例化哪一个类。 工厂方法使一个类的实例化延迟到其子类。
角色: Product、Creator（+FactoryMethod）、ConcreteCreator、ConcreteCreator
抽象产品类Product。可以又多个具体产品类去extends Product。
抽象工厂类Creator：定义产生产品对象的方法，由一个具体工厂去extends Creator
场景类、客户端类：传入想要生产的具体产品给具体工厂类，由具体工厂类返回一个抽象产品Product（具体类）
3.优点与缺点
优点：封装良好，代码结构清晰；扩展性非常优秀；屏蔽了产品类；是典型的解耦框架

4.应用场景
是呢我一个对象的替代品、需要灵活可扩展的框架时可以考虑工厂方法模式；可以使用在测试驱动开发框架下

5.工厂方法模式的扩展
缩小为简单工厂模式：一个模块仅需一个工厂类，就没有必要生产出来，使用静态方法就好啦。省掉抽象工厂类
多工厂模式的抽象：抽象工厂类中的抽象方法不需要再传递参数，每一个具体的工厂都会由自己的实现方式。复杂的多工厂模式可以增加一个协调类
使用工厂模式实现单例：单例类中没有产生单例的方法，符合单一原则。那么可以使用SingletonFactory，反射的方式胜场一个Singleton
延迟对象的初始化：重要，看设计模式之禅